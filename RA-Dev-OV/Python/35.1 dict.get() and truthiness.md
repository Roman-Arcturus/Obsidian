# Topic: Safe dictionary access and truthiness as a design tool

---

## Part 1: `dict.get()` — safe access, nothing more

### What it is

`dict.get(key, default)`:
- Returns the value associated with `key` if it exists
- Otherwise returns `default`
- Never raises `KeyError`

Example:

`value = some_dict.get("key", fallback)`

---
### Why it’s useful

- Prevents runtime failures at data boundaries
- Makes **missing data an explicit design case**
- Avoids defensive `if key in dict` noise

Crucially:

> `.get()` does **not** validate, normalize, or copy data.

It only solves **existence**, not **correctness**.

---

### Unified mental model

> `.get()` answers one question only:  
> **“Is the key present?”**

It does _not_ answer:
- “Is the value usable?”
- “Is the value meaningful?”
- “Is the value empty?”

Those are your responsibility.

---

## Part 2: Truthiness — intentional ambiguity

### What it is

In Python, objects can be evaluated in boolean context:

`if value:     ...`

The following are considered **False**:
- `None`
- `False`
- `0`
- `0.0`
- `""` (empty string)
- `[]`, `{}`, `set()`

Everything else is **True**.

---

### Why it’s useful

Truthiness allows you to:
- Collapse multiple checks into one
- Express intent (“usable value”) instead of structure
- Write compact, readable normalization code

But:

> Truthiness is a **semantic tool**, not a convenience trick.

Used incorrectly, it hides meaning.  
Used correctly, it encodes invariants.

---

### Unified mental model

> Truthiness answers:  
> **“Does this value meaningfully exist for my purpose?”**

Not:

- “Is it present?”
- “Is it correct?”
- “Is it the right type?”

```
def safe_user_name(user: dict) -> str:
    name = user.get("name")

    if not name:
        return "unknown"

    return name
```

Why this works
`.get("name")` handles missing keys

`if not name` handles:
None
""
The function guarantees a non-empty string

This establishes a strong invariant.

## Design rule to internalize (important)

> Use `.get()` to handle **absence**.  
> Use truthiness to handle **emptiness**.

Never confuse the two.

safe get() with type check
```
def safe_tags(user: dict) -> list[str]:
    tags = user.get("tags")

    if not isinstance(tags, list) or not tags:
        return []

    return list(tags) # returns a safe copy
```

